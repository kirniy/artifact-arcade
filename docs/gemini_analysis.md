Technical Audit and Remediation Strategy for High-Density 64x64 HUB75 Display Integration in the ARTIFACT Arcade System1. Executive Summary and Architectural AssessmentThe "ARTIFACT" modular arcade system represents a sophisticated convergence of retro-gaming aesthetics and modern embedded systems engineering. Based on the comprehensive diagnostic review of the provided repository structure, hardware specifications, and error manifestations, it is evident that the current display failure—characterized by blocky visual artifacts, incomplete rendering, and signal instability—is not a singular defect but the result of a "perfect storm" of three distinct architectural conflicts. These conflicts exist at the physical layer (wiring topology), the data link layer (signal addressing), and the application layer (resource arbitration).The core of the system relies on a Raspberry Pi 4 Model B to drive a high-density 64x64 RGB LED matrix via the rpi-rgb-led-matrix library.1 The visual evidence provided—specifically the "blocky" display where large sections are either blank or mirroring other sections—confirms a failure in the row addressing logic. This is compounded by a critical hardware resource contention on General Purpose Input/Output (GPIO) pin 18, which is currently assigned simultaneously to two time-sensitive peripherals: the Matrix Output Enable (OE) signal and the WS2812B "NeoPixel" data stream. Finally, the erratic behavior suggests an uninitialized LED driver chipset, likely the FM6126A series common in modern P2.0-P3.0 panels.This report delivers a definitive, engineered solution. It moves beyond heuristic guessing to provide a calculated remediation path rooted in the electrical specifications of the HUB75 protocol and the BCM2711 System-on-Chip (SoC) architecture. The remediation strategy is tripartite:Physical Address Expansion: Enabling the 5th bit of binary addressing (Line E) to support 1:32 scan rates.Resource Deconfliction: Relocating the WS2812B telemetry to a non-conflicting SPI interface to restore PWM integrity for the matrix.Driver Initialization Protocol: Implementing specific software flags to unlock the panel's shift registers.2. Theoretical Framework: HUB75 Protocol and High-Density AddressingTo implement a robust fix, one must first understand the signaling mechanics that are currently failing. The term "HUB75" refers not to a standardized industry specification, but to a de facto pinout standard derived from early LED control cards. It is a parallel interface that shifts RGB data into registers while using address lines to multiplex rows.2.1 The Mathematics of MultiplexingStandard low-density panels (e.g., 32x32 or 32x16) typically utilize a 1:16 scan rate. In this topology, the panel is electrically divided into two halves: the top 16 rows and the bottom 16 rows.Parallel Data: At any given clock cycle, the controller sends data for two pixels simultaneously: one on row $N$ (via lines R1, G1, B1) and one on row $N+16$ (via lines R2, G2, B2).Row Selection: To determine which row $N$ is currently active, the controller uses a binary address bus. For 16 rows (0-15), 4 bits of data are required, because $2^4 = 16$. These are designated Address Lines A, B, C, and D.The 64x64 Paradigm Shift:The ARTIFACT system utilizes a 64x64 panel. To maintain the same parallel driving structure without doubling the data lines, manufacturers increased the scan rate to 1:32.The panel is still divided into two halves, but each half now contains 32 rows (Rows 0-31 and Rows 32-63).To address 32 unique rows, the address bus must expand. The mathematical requirement shifts to $2^5 = 32$.This necessitates a 5th Address Line, universally designated as Line E in the HUB75E variant.22.2 Failure Mechanism: The Floating E-LineThe specific visual artifacts described—"displaying something like this... displaying blocky"—are practically diagnostic of a missing E-line signal.The Scenario: The software, configured for 64x64, attempts to render Row 17. In binary, Row 17 is 10001 (DCBAA).The Hardware Reality: If the HAT or wiring does not physical connect the E-pin (the Most Significant Bit), the panel only receives the lower 4 bits: 0001.The Result: Instead of lighting up Row 17, the panel lights up Row 1 (binary 0001).Visual Manifestation: This causes "aliasing" or "wrapping" of the image. The content meant for the lower quadrant of the top half (rows 16-31) wraps around and overwrites the top quadrant (rows 0-15). The bottom half of the screen behaves similarly. This results in the "blocky," jumbled mess where the image appears sliced and stacked incorrectly.32.3 Interface Hardware ConstraintsThe CLAUDE.md file indicates the use of an Adafruit RGB Matrix HAT/Bonnet.1 Historically, these HATs were designed when 32x32 panels were the standard. On a standard HUB75 connector (IDC-16), Pin 8 and Pin 16 were tied to Ground.Modern Panels: On a 64x64 panel, Pin 8 (or sometimes Pin 4) is repurposed from Ground to Signal E.The Gap: If the HAT hardwires Pin 8 to Ground (default state), the E-signal from the Pi is shunted to earth, effectively forcing the MSB to logical '0' forever. This guarantees the addressing failure described above.3. Diagnostic Analysis of Current InfrastructureBefore detailing the remediation, we must confirm the specific configuration faults in the ARTIFACT system based on the provided repository data.3.1 Wiring Architecture AuditThe CLAUDE.md file provides a snapshot of the current wiring table 1:InterfaceDeviceGPIO/ConnectionNotesSPIRGB Matrix/dev/spidev0.0Incorrect attribution in docsGPIO 18WS2812B LEDsPWM (audio disabled)CRITICAL CONFLICTI2CLCD 16x2GPIO 2, 3StandardUARTPrinterGPIO 14, 15StandardCritical Observation 1: The SPI MisconceptionThe documentation states the RGB Matrix connects via spidev0.0. This is technically inaccurate for the rpi-rgb-led-matrix library. While some drivers use SPI, the Hzeller library (standard for high performance) uses a parallel GPIO bit-banging method that consumes a massive block of GPIO pins (A, B, C, D, E, CLK, LAT, OE, R1, G1, B1, R2, G2, B2). It does not strictly use the SPI bus protocol, although it may physically occupy SPI pins.Critical Observation 2: The GPIO 18 CollisionThe most catastrophic error in the current setup is the assignment of GPIO 18 to the WS2812B LED strips.Matrix Requirement: To achieve a stable, flicker-free image with high color depth (11-bit PWM), the matrix driver must use the Raspberry Pi's hardware Pulse Width Modulation (PWM) peripheral to generate the Output Enable (OE) signal. This timing is too tight for software toggling. On the Raspberry Pi 4, the primary hardware PWM channel is exposed on GPIO 18.5NeoPixel Requirement: The rpi_ws281x library defaults to using PWM to generate the precise 800kHz timing signal for addressable LEDs. It also defaults to GPIO 18.The Conflict: Both libraries are attempting to seize control of the BCM2711's PWM0 peripheral.If the Matrix library initializes first, the NeoPixel library will fail or overwrite the PWM registers.If the NeoPixel library runs, it will likely output a data stream that the Matrix interprets as a chaotic OE signal, causing the screen to flash wildly or go dark.The documentation notes "audio disabled," which is a prerequisite for using PWM on GPIO 18, but it does not account for two digital devices fighting for the pin.73.2 Display Driver Chipset AnalysisThe user prompt mentions "trying lots of options including multiplexing." This trial-and-error approach often misses the initialization requirement of modern driver chips.FM6126A/ICN2038S: These chips act as "smart" shift registers. Unlike generic logic chips, they have configuration registers that control gain, brightness, and power-saving modes.The Lockout: Upon power-up, these chips often default to a "standby" state where the display is blank or high-impedance to prevent power surges. They require a specific "unlock" sequence—a precise pattern of clock pulses and latch signals—before they will accept any pixel data.Symptoms: If the library treats them as standard chips, it sends pixel data immediately. The chips ignore this data, resulting in a black screen or random static (if the drivers pick up noise).94. Comprehensive Remediation PlanThis plan is structured chronologically: Physical Layer -> Driver Layer -> Software Layer. All steps must be executed in order.Phase 1: Hardware Modification (The "E-Line" Bridge)The Adafruit RGB Matrix HAT/Bonnet is designed to be universal, but it defaults to legacy compatibility. To drive a 64x64 panel, you must physically close a circuit on the PCB.Procedure:Inspect the HAT: Remove the HAT from the Raspberry Pi. Locate the 2x8 IDC header (where the matrix ribbon cable plugs in).Locate the Jumpers: On the top surface of the board, near the IDC header, identify the solder pads labeled Address E. You will see a central pad and two option pads labeled 8 and 16.4Note: These numbers correspond to the pin on the IDC connector.Perform the Mod: Use a soldering iron to bridge the Center Pad to Pad 8.Why 8? The vast majority of 64x64 panels (Hub75E) map the E-signal to Pin 8 of the input header. Pin 4 is sometimes used, and Pin 16 is extremely rare.Verification: If you have a multimeter, verify continuity between GPIO 24 on the 40-pin header and Pin 8 on the IDC output.Consequence: This physically routes the signal from GPIO 24 (Address E) to the panel. Without this, the panel will never display the image correctly, regardless of code changes.Phase 2: Resolving the GPIO 18 Resource ConflictYou cannot run the Matrix OE and the NeoPixels on GPIO 18 simultaneously. The Matrix takes priority because its timing requirements are stricter (nanosecond precision) and it requires the hardware PWM.Procedure:Physical Relocation: Move the data wire for the WS2812B LED strip from GPIO 18 (Pin 12) to GPIO 10 (Pin 19) or GPIO 21 (Pin 40).Recommendation: Use GPIO 10 (SPI0 MOSI). The rpi_ws281x library has a dedicated SPI driving mode. This uses the SPI peripheral to generate the 800kHz signal, leaving the PWM peripheral free for the Matrix.12Verify Ground: Ensure the LED strip shares a common ground with the Raspberry Pi. Data signals without a reference ground are a common source of flicker.Phase 3: Software Configuration and Driver FlagsWith the hardware paths cleared, we must now instruct the software to utilize them correctly. "Guessing" flags is inefficient; we will derive the correct flags from the hardware topology.The "Holy Grail" Configuration:The rpi-rgb-led-matrix library (and its Python bindings) requires a specific set of arguments to handle the Pi 4's speed, the 64x64 geometry, and the FM6126A chipset.Recommended Flag Set:Bash--led-rows=64 
--led-cols=64 
--led-gpio-mapping=adafruit-hat 
--led-slowdown-gpio=4 
--led-multiplexing=0 
--led-panel-type=FM6126A
Detailed Rationale for Each Flag:FlagValueRationale based on Analysisled-rows / led-cols64Defines the physical geometry. Essential for the buffer calculation.led-gpio-mappingadafruit-hatTells the driver to use the specific pinout wired on the Adafruit PCB. Crucially, this map assigns the E-line to GPIO 24.4 If you use "regular", it might map E to a different pin, causing the fix in Phase 1 to fail.led-slowdown-gpio4Critical for Pi 4. The Pi 4 CPU (Cortex-A72) switches GPIOs faster than the level shifters on the HAT can handle (propagation delay). Setting this to 4 injects wait-states. Without it, the image will be full of "snow," static, or random colors.3led-multiplexing0(Direct). Most indoor 64x64 panels use standard direct addressing. "Stripe" or "Z-stripe" are for outdoor panels. Start with 0.led-panel-typeFM6126AThe Magic Bullet. This enables the special initialization sequence required to unlock the driver chips. If your panel uses standard chips, this usually does no harm. If it uses FM6126A (likely), this is mandatory for any image to appear.9Phase 4: Code ImplementationWe must now integrate these findings into the ARTIFACT codebase. Based on the file list, the configuration likely resides in modular-arcade/src/artifact/hardware/display/__init__.py or a dedicated settings file.Step 1: Update the Matrix InitializationLocate the RGBMatrixOptions instantiation and force the following parameters. Do not rely on command-line argument passing alone if the app starts programmatically.Pythonfrom rgbmatrix import RGBMatrix, RGBMatrixOptions

def create_matrix_options():
    options = RGBMatrixOptions()
    options.rows = 64
    options.cols = 64
    options.chain_length = 1
    options.parallel = 1
    
    # HARDWARE MAPPING: Matches the Adafruit HAT pinout
    options.hardware_mapping = 'adafruit-hat' 
    
    # SLOWDOWN: Essential for Raspberry Pi 4 signal integrity
    options.gpio_slowdown = 4
    
    # CHIPSET: Mandatory for modern P3/P2.5 panels to unlock display
    options.panel_type = 'FM6126A' 
    
    # PWM: We enabled the E-line and moved the NeoPixels, so we can
    # safely use hardware pulsing for flicker-free performance.
    options.disable_hardware_pulsing = False 
    
    # BRIGHTNESS: Start lower to limit current draw on the 5V rail
    options.brightness = 80

    return options
Step 2: Update the WS2812B ConfigurationModify the file controlling the ambient lights (src/artifact/hardware/lights.py or similar).Pythonimport board
import neopixel

# UPDATED PIN ASSIGNMENT
# Was board.D18 (Conflict) -> Now board.D10 (SPI)
pixel_pin = board.D10 

# Note: running NeoPixels via SPI on Pi requires root privileges,
# which the Matrix library also requires, so this is compatible.
num_pixels = 30
pixels = neopixel.NeoPixel(pixel_pin, num_pixels, brightness=0.5, auto_write=False, pixel_order=neopixel.GRB)
Step 3: System ConfigurationEnsure the audio driver is blacklisted to free up the hardware PWM generator.Edit /boot/config.txtEnsure dtparam=audio=off is present and uncommented.Reboot the Pi.5. Troubleshooting MatrixIf issues persist after applying the above fixes, consult this differential diagnosis table:SymptomProbable CauseCorrective ActionImage wrapped / doubled verticallyE-Line physical disconnectCheck solder bridge on HAT (Pad 8 to E). Check continuity GPIO 24 -> HUB75 Pin 8.Blank screen / No lightDriver Chip LockoutEnsure options.panel_type = 'FM6126A' is set. Verify 5V power to panel.Random sparkles / Color snowSignal Integrity (Speed)Increase gpio_slowdown to 5. Check ribbon cable seating.Flickering barsPWM Resource ConflictVerify NeoPixels are NOT on GPIO 18. Verify dtparam=audio=off.Top half perfect, bottom blackBad Ribbon Cable / InputThe data for the bottom half (R2, G2, B2) is not reaching the panel. Reseat ribbon cable.6. Power ConsiderationsA 64x64 RGB matrix contains 4,096 LEDs.Max Draw: At full white (all LEDs on), current can exceed 4.0 Amps.Typical Draw: For arcade interfaces (mostly black backgrounds), 1.5 - 2.0 Amps is typical.Risk: Powering the matrix solely through the Raspberry Pi GPIO header is unsafe. It can brown-out the Pi.Requirement: The matrix must be powered directly from the 5V PSU using the fork-terminal power cable provided with the panel. The Pi and the Matrix should share a common Ground reference, but the high-current positive rail should bypass the Pi's sensitive traces.7. ConclusionThe "ARTIFACT" display issues are a solvable integration challenge. The root cause is a mismatch between the 64x64 hardware requirements (5-bit addressing, specific drivers) and the default configuration of the Adafruit HAT (4-bit addressing) and the software (standard driver, GPIO conflict).By soldering the E-line jumper, migrating the ambient LEDs to GPIO 10, and explicitly defining the FM6126A panel type and slowdown settings, the system will align the physical, electrical, and logical layers required for operation. This approach eliminates the need for "guessing" and provides a stable, engineering-grade foundation for the arcade software.1. Introduction: The HUB75 Integration ChallengeThe development of the "ARTIFACT" modular arcade system faces a critical impediment in its visual subsystem. The primary display—a 64x64 RGB LED matrix—is failing to render graphical data correctly, exhibiting "blocky" artifacts, missing scan lines, and image duplication. These symptoms are characteristic of a desynchronization between the software driver's addressing logic and the physical panel's hardware topology.Unlike standardized display interfaces (HDMI, DSI) where negotiation is automated, the HUB75 protocol used by these matrices is a "dumb" parallel interface. It requires the host controller (the Raspberry Pi 4) to manually handle every aspect of signal timing, row addressing, and color modulation (via Pulse Width Modulation or PWM). Consequently, even minor misconfigurations in wiring or software initialization manifest as catastrophic visual failures.This report analyzes the specific hardware ecosystem of the ARTIFACT project—comprising a Raspberry Pi 4 Model B, Adafruit RGB Matrix HAT, and a 64x64 P3 LED panel—to identify the precise points of failure. The analysis reveals that the reported issues stem from three distinct but interacting root causes:Address Space Mismatch: A physical disconnection of the 5th address bit (Line E) required for 1:32 scan panels.Hardware Resource Collision: A fatal conflict over the PWM0 peripheral (GPIO 18) between the matrix driver and the ambient lighting system.Driver Initialization Failure: The omission of specific "unlock" sequences required by modern FM6126A/ICN2038S display drivers.The following sections detail the theoretical basis of these failures and provide a comprehensive, step-by-step remediation strategy to restore full system functionality.2. Hardware Architecture & Signal TheoryTo understand why the display is "blocky" and "glitchy," we must first dissect how the 64x64 matrix expects to receive data versus how the current setup is transmitting it.2.1 The Scan Rate and Address TopologyLED matrices are multiplexed devices. They do not illuminate all 4,096 pixels simultaneously, which would require excessive current (over 10 Amps). Instead, they scan through rows at high speed to create the persistence of vision (POV) illusion of a static image.The Standard 1:16 vs. High-Density 1:321:16 Scan (Standard 32x32 Panels): The controller drives 2 rows at a time (one in the top half, one in the bottom half). To cycle through 16 rows, it needs 4 address bits ($2^4 = 16$). These are carried on pins designated A, B, C, and D.1:32 Scan (High-Density 64x64 Panels): To achieve 64 pixels of vertical resolution, the panel is split into two zones of 32 rows each (Rows 0-31 and Rows 32-63). To select one row out of 32, the addressing logic requires 5 bits ($2^5 = 32$). This necessitates a 5th Address Line, designated as Line E.The Anatomy of the FailureThe "blocky" artifact described by the user is a textbook symptom of address aliasing.The Glitch: When the software tries to display data on Row 16 (Binary 10000), it asserts the E-line (the 1) and de-asserts A-D (the 0000).The Disconnect: If the E-line is not physically connected on the HAT (which is the default state for compatibility with older panels), the panel never sees the "1". It only sees 0000.The Result: The panel interprets the address as Row 0. Consequently, the graphical data intended for the middle of the screen is physically rendered at the top, overwriting the correct data for Row 0. This folding of the address space causes the image to appear jumbled, repeated, or blocked.2.2 The FM6126A Driver ConstraintModern high-density panels have moved away from generic shift registers to intelligent driver chips like the FM6126A or ICN2038S. These chips solve a specific electrical problem: "ghosting" or "caterpillar effects" caused by residual charge in the LEDs during row switching.The Lock Mechanism: To prevent power-on garbage data from displaying, these chips boot up in a "locked" or high-impedance state. They will not display any pixels until they receive a specific initialization command sequence.The Symptom: If the rpi-rgb-led-matrix library is initialized with standard settings, it assumes generic drivers and skips the unlock sequence. The panel remains black, or if signal integrity is poor, interprets noise as random commands, leading to "static" or "sparkles." The user's report of "unable to make them work properly" suggests this lockout is active.2.3 The GPIO 18 (PWM0) Resource ConflictThe Raspberry Pi 4 has limited hardware peripherals. The rpi-rgb-led-matrix library is engineered for performance; it eschews software timing (which jitters under load) in favor of the Pi's hardware Pulse Width Modulation (PWM) engine to generate the Output Enable (OE) pulses. This is critical for achieving varying brightness levels (color depth) without flicker.The Conflict: The project's CLAUDE.md explicitly lists: GPIO 18 WS2812B LEDs. The WS2812B driver (rpi_ws281x) also defaults to using the PWM0 peripheral on GPIO 18 to generate its specific 800kHz timing signal.The Outcome: Two drivers cannot own the same hardware peripheral. When the Matrix driver engages, it seizes GPIO 18. When the LED strip driver engages, it attempts to seize it back. This resource thrashing results in corrupted signals sent to both devices. The matrix sees its OE signal garbled (causing flickering or full-on brightness), and the LED strips receive matrix timing pulses (causing blinding white flashes).3. Remediation StrategyResolving these issues requires a systematic approach: modifying the physical hardware to support 64x64 addressing, de-conflicting the GPIO resources, and configuring the software to match the specific silicon of the panels.Phase 1: Hardware Modification (The E-Line Bridge)The Adafruit RGB Matrix HAT/Bonnet is sold in a configuration compatible with 32x32 panels. To support the 64x64 panels used in ARTIFACT, we must manually enable the 5th address line.Table 1: HUB75 vs. Raspberry Pi GPIO Mapping (Adafruit HAT)HUB75 SignalFunctionGPIO PinNoteAAddress Bit 0GPIO 22ConnectedBAddress Bit 1GPIO 26ConnectedCAddress Bit 2GPIO 27ConnectedDAddress Bit 3GPIO 20ConnectedEAddress Bit 4GPIO 24Disconnected by DefaultThe Fix:Remove the HAT from the Raspberry Pi.Locate the Address E Jumpers on the top surface of the HAT (near the HUB75 connector). You will see pads labeled 8 and 16.Context: Most panels map the E signal to Pin 8 of the IDC connector. A minority use Pin 16.Bridge 8 to E: Using a soldering iron, melt a small blob of solder to bridge the central pad labeled E to the pad labeled 8.Verification: This creates a physical path from GPIO 24 to Pin 8 on the matrix connector. Without this bridge, the software toggling GPIO 24 effectively talks to nothing, explaining the "missing lines" and blocky artifacts.4Phase 2: Resolving the GPIO 18 ConflictWe must liberate GPIO 18 for the exclusive use of the LED Matrix to ensure visual stability. This requires moving the WS2812B LED strip to an alternative pin that supports a different hardware peripheral.Strategy: Migration to SPIThe Raspberry Pi's SPI (Serial Peripheral Interface) hardware can be repurposed to drive WS2812B LEDs. This is supported by the rpi_ws281x library and uses GPIO 10 (MOSI). Using SPI for the LEDs completely bypasses the PWM peripheral, resolving the conflict.Action Items:Wiring Change: Move the WS2812B Data Input wire from GPIO 18 (Physical Pin 12) to GPIO 10 (Physical Pin 19).Software Update: Update the NeoPixel initialization code in src/artifact/hardware/lights.py (or equivalent).Pythonimport board
import neopixel

# OLD: pixel_pin = board.D18
# NEW: Use SPI MOSI pin
pixel_pin = board.D10 

# Note: Running NeoPixels via SPI requires root privileges (sudo),
# which matches the requirement for the RGB Matrix library.
pixels = neopixel.NeoPixel(pixel_pin, 30, brightness=0.5, auto_write=False)
Phase 3: Driver Configuration and FlagsWith the hardware path established, we must configure the rpi-rgb-led-matrix driver to utilize the E-line and unlock the FM6126A chips. The current "guessing" of multiplexing flags must be replaced with deterministic configuration.The Correct Configuration Object:The Python bindings for the matrix library accept an RGBMatrixOptions object. This must be populated with the specific parameters derived from our hardware analysis.Table 2: Required Configuration ParametersParameterValueTechnical Justificationrows64Physical geometry of the panel.cols64Physical geometry of the panel.chain_length1Assuming a single panel or single chain topology.parallel1Standard HATs support 1 parallel chain.hardware_mapping'adafruit-hat'Crucial. This maps the logical "E-Line" to GPIO 24. Using "regular" or "classic" mappings will send the E-signal to the wrong pin (e.g., GPIO 15), causing the address failure to persist.4gpio_slowdown4Crucial for Pi 4. The Pi 4 switches GPIO pins faster than the 74AHCT245 buffers on the HAT can respond. Setting this to 4 introduces wait-states, eliminating "snow" and random pixel sparkles.3panel_type'FM6126A'Crucial for Artifacts. This enables the initialization pulse train required to wake up the driver chips. Without this, the panel stays blank or shows static.9disable_hardware_pulsingFalseSince we moved the WS2812B LEDs, we can now safely enable hardware pulsing (set disable to False). This vastly improves color stability and prevents flickering.Implementation CodeThe following function should replace the existing matrix initialization logic in the ARTIFACT codebase:Pythonfrom rgbmatrix import RGBMatrix, RGBMatrixOptions

def initialize_matrix():
    options = RGBMatrixOptions()
    options.rows = 64
    options.cols = 64
    options.chain_length = 1
    options.parallel = 1
    options.hardware_mapping = 'adafruit-hat'  # Maps E-line to GPIO 24
    options.gpio_slowdown = 4                # Essential for Pi 4 stability
    options.panel_type = 'FM6126A'           # Unlocks the driver chips
    
    # We moved the NeoPixels, so we can use high-quality hardware PWM
    options.disable_hardware_pulsing = False 
    options.pwm_bits = 11                    # High color depth
    options.brightness = 100

    return RGBMatrix(options=options)
4. Troubleshooting and VerificationAfter applying these fixes, valid operation can be verified through specific observation of the display behavior.Verification of E-Line Fix: Run a test pattern that draws a single horizontal line at Y=0.Pass: Only the top row lights up.Fail: Both the top row (Y=0) and the middle row (Y=32) light up. This indicates the E-line is still disconnected; check the solder bridge on the HAT.Verification of FM6126A Fix: Run the standard demo.Pass: Display lights up immediately with correct colors.Fail: Display remains black or shows random static. This suggests the initialization sequence failed. Try power-cycling the panel (remove 5V) completely, as these chips sometimes latch into a fault state.Verification of GPIO Conflict: Run the matrix and the LED strip simultaneously.Pass: Both devices operate smoothly.Fail: Matrix flickers or LED strip flashes white. This indicates the WS2812B data line is still electrically connected to GPIO 18, or the software configuration was not updated to GPIO 10.5. ConclusionThe instability of the ARTIFACT display system is the result of well-understood limitations in legacy hardware adapters when paired with modern high-density components. The Adafruit HAT requires manual modification to support the 5th address bit needed for 64x64 resolution. Simultaneously, the Raspberry Pi's limited hardware resources necessitate careful arbitration of the PWM peripheral, forcing the relocation of the ambient lighting system.By soldering the E-line jumper, migrating the WS2812B data line to SPI (GPIO 10), and explicitly configuring the driver for the FM6126A chipset and Pi 4 timing, the system will achieve the pixel-perfect, stable output required for the application. This moves the project from a state of experimental "guessing" to a deterministic, engineered solution.